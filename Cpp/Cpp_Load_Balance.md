## 负载均衡算法的实现

> **负载平衡**（英语：load balancing）是一种[电子计算机](https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA "电子计算机")技术，用来在多个计算机（[计算机集群](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4 "计算机集群")）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过[冗余](https://zh.wikipedia.org/wiki/%E5%86%97%E4%BD%99 "冗余")提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的[高并发](https://zh.wikipedia.org/wiki/%E5%B9%B6%E5%8F%91%E6%80%A7 "并发性")和[高可用](https://zh.wikipedia.org/wiki/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7 "高可用性")的问题。

这是[维基百科]([负载均衡 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1))对负载均衡的定义。

按照我的理解，负载均衡主要就是为了两个目的：并行处理(A忙不过来，B一起上)、防止单点失败(A忙废了，B顶上)。分别对应了高并发、高可用的核心诉求。

负载均衡的算法有很多种，我尝试把我的理解表达出来。陆游老先生曾经曰过：纸上得来终觉浅，绝知此事要躬行。所以，用C++把它们实现一下。

#### 1. 轮询 Round Robin

轮询，就是将请求逐个分发给后端的服务器，每个服务器都被平等对待。

#### 2. 加权轮询 Weighted Round Robin

后端的服务器，有些强劲、有些比较弱。可以给强劲的服务器分配较大的权重，给它分发更多的请求。

#### 3. 随机 Random

随机算法也很好理解，每次过来一个请求，随机分发给某一台后端服务器即可。随着请求量的增加，每个后端服务器的请求总数会趋向一致。

#### 4. 加权随机 Weighted Random

加权随机与加权轮询的思路类似，给强劲的后端服务器更大的权重(出现次数更多)，让它更容易被随机选中。

#### 5. 源地址哈希 Source IP Hash

根据客户端的IP地址，通过Hash算出个数值后，对后端服务器的总数取模，然后把请求分发给取模得到的服务器。

#### 6. 一致性哈希 Consistent Hashing

一致性哈希是现在用的比较广泛的算法，具体我就不解释了，网上资料非常多。[维基百科]([一致哈希 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C))的描述也很清楚：

> 一致哈希将每个对象映射到圆环边上的一个点，系统再将可用的节点机器映射到圆环的不同位置。查找某个对象对应的机器时，需要用一致哈希算法计算得到对象对应圆环边上位置，沿着圆环边上查找直到遇到某个节点机器，这台机器即为对象应该保存的位置。 当删除一台节点机器时，这台机器上保存的所有对象都要移动到下一台机器。添加一台机器到圆环边上某个点时，这个点的下一台机器需要将这个节点前对应的对象移动到新机器上。 更改对象在节点机器上的分布可以通过调整节点机器的位置来实现。

#### 7. 最小连接数法 Least Connection

检测所有后端服务器中，连接数最少的一个，然后把请求分发给它。连接数少，可以认为它处理的快，那么能者多劳，再多处理一点。

这个需要去统计、获取后端服务器的连接数，然后才能判断。就不实现了。
